<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gcode box</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 10px;
            background-color: #000000;
            overflow: hidden;
        }

        #display {
            width: 300px;
            height: 300px;
        }

        .settings {
            position: absolute;
            color: white;
        }

        .settings #params label {
            text-align: right;
        }

        .settings label {
            display: inline-block;
            width: 150px;
        }

        .settings input {
            width: 50px;
        }

        #g-code {
            width: 200px;
            height: 100px;
        }

    </style>
</head>
<body>
<div class="settings">
    <legend id="params">
        <label for="params">Settings</label>

        <div>
            <label>Number Of Teeth</label>
            <input type="number" placeholder="width" min="3" onchange="changeParam('numberOfTeeth',this);" value="52"/>
        </div>
        <div>
            <label>Teeth diametr, mm</label>
            <input type="number" placeholder="height" onchange="changeParam('teethDiametr',this);" value="0.55"/>
        </div>
        <div>
            <label>Work Speed</label>
            <input onchange="changeSize('workSpeed',this);" type="number" placeholder="Work Speed" value="150"/>
        </div>
        <div>
            <label>Speed</label>
            <input onchange="changeSize('speed',this);" type="number" placeholder="Speed" value="400"/>
        </div>
        <div>
            <label>Laser Power</label>
            <input onchange="changeSize('laserPower',this);" type="number" placeholder="clamp" value="200"/>
        </div>
    </legend>
    <legend id="export">
        <label for="export">Export</label>

        <div>
            <!--<button>DXF</button>-->
            <!--<button>SVG</button>-->
            <button onclick="dataExport('g-code');">G code</button>
        </div>
        <textarea id="g-code"></textarea>
    </legend>
</div>
<script src="three.js"></script>

<script>
    var gt2Constants = {
        '2': {
            'grooveDepth': 0.76,
            'pitchFactor': 0.41,
            'pld': 0.254
        },
        '3': {
            'grooveDepth': 1.14,
            'pitchFactor': 1.27
        },
        '5': {
            'grooveDepth': 1.93,
            'pitchFactor': 1.78
        }
    };

    var numberOfTeeth = 15;
    var teethDiametr = 0.55;
    var gears = [];
    var camera, scene, renderer;
    var mesh;

    function degToRad(angle) {
        return (angle * Math.PI) / 180;
    }


    function changeParam(type, el) {

        if (type == 'numberOfTeeth') {
            numberOfTeeth = parseInt(el.value);
        } else if (type == 'teethDiametr') {
            teethDiametr = parseFloat(el.value);

        }

        gears.forEach(function (gear) {
            scene.remove(gear.line);
        });


        makeGear(numberOfTeeth, teethDiametr, 0);


    }

    function polar(x, y, direct, dist) {
        return {
            'x': ((dist * Math.cos(direct)) + x),
            'y': ((dist * Math.sin(direct)) + y),
            'z': 0
        }
    }

    function radToDeg(angle) {
        return (angle * 180) / PI;
    }


    function addPath(teeth) {
        teeth.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(teeth.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = teeth.path.length; i < l; i++) {
            var positions = teeth.geometry.attributes.position.array;
            positions[index++] = teeth.path[i].y;
            positions[index++] = teeth.path[i].z;
            positions[index++] = teeth.path[i].x;
        }
    }


    function generateTeeth(path, teethAngle, teethCenter, angle, teethRadius, toolRadius, oneTeethAngle, outsideRadius) {

        teethAngle = 170;


        var angleDiff = (180 - (teethAngle)) / 2;

        console.log('diff', angleDiff);


        var teethInsideEdge = (teethAngle + angle ) + angleDiff;

//        teethInsideEdge +=angleDiff;

        console.log('diff', angleDiff, teethInsideEdge);


//        console.log(teethAngle);
//        console.log(teethInsideEdge, angle, teethInsideEdge - angle);

        var roundRadius = 0.15;

        console.log(degToRad(angle - oneTeethAngle), degToRad(angle - oneTeethAngle + 180));

        var leftEdgePoint = polar(teethCenter.x, teethCenter.y, degToRad(teethInsideEdge + 90), teethRadius);
        var leftCenterPoint = polar(leftEdgePoint.x, leftEdgePoint.y, degToRad(teethInsideEdge + 90), roundRadius);
        var roundAngle = teethInsideEdge;
        while (roundAngle < teethInsideEdge + 90) {
            path.push(polar(leftCenterPoint.x, leftCenterPoint.y, degToRad(roundAngle + 180), roundRadius));
            roundAngle++;
        }
        while (teethInsideEdge > (angle + angleDiff)) {

            path.push(polar(teethCenter.x, teethCenter.y, degToRad(teethInsideEdge + 90), teethRadius));
            teethInsideEdge--;
        }

//        path.push(polar(0, 0, degToRad(angle + (oneTeethAngle / 3.3)), outsideRadius));


        var rightEdgePoint = polar(teethCenter.x, teethCenter.y, degToRad(angle + 90+ angleDiff), teethRadius);
        var rightCenterPoint = polar(rightEdgePoint.x, rightEdgePoint.y, degToRad(angle + 90+ angleDiff), roundRadius);
        var roundAngle = teethInsideEdge;
        while (roundAngle < teethInsideEdge + 90) {
            path.push(polar(rightCenterPoint.x, rightCenterPoint.y, degToRad(roundAngle - 90), roundRadius));
            roundAngle++;
        }

//        var roundCornerRadius = outsideRadius - 0.15;

//        roundCornerRadius


//        var position = {x: 0, y: 0, z: 0};


    }

    function makeGear(numberOfTeeth, teethRadius, toolRadius) {

        var oneTeethAngle = (360 / numberOfTeeth);
        var angle = 0;

        var geometry = new THREE.BufferGeometry();
        var material = new THREE.LineBasicMaterial({
            color: 0xFF0000
        });

        var pitchRadius = (((2 * numberOfTeeth) / Math.PI) / 2);
        var pitchDiametr = pitchRadius * 2;
        var outsideDiameter = pitchDiametr - (0.254 * 2);
        var outsideRadius = outsideDiameter / 2;


        var rootDiameter = outsideDiameter - (gt2Constants['2'].grooveDepth * 2);
        var rootRadius = rootDiameter / 2;

        console.log(pitchDiametr, outsideDiameter, rootDiameter);

        var gear = {
            'geometry': geometry,
            'path': [],
            'numberOfTeeth': numberOfTeeth,
            'teethRadius': teethRadius,
            'toolRadius': toolRadius,
            'line': new THREE.Line(geometry, material)
        };

        var teethInsideAngle = ((180 - ((oneTeethAngle / 2) + 90)) * 2);
        teethInsideAngle = 180;


        //0.366
//        console.log(oneTeethAngle, teethInsideAngle);
        var teethCenter;
        var teethCenter;
        var outsidePoint;
        for (var i = 0; i <= numberOfTeeth;) {

//            outsidePoint = polar(0, 0, degToRad(angle - (oneTeethAngle / 3)), outsideRadius);
//            gear.path.push(outsidePoint);

            teethCenter = polar(0, 0, degToRad(angle), (rootRadius + 0.555));
            generateTeeth(gear.path, teethInsideAngle, teethCenter, angle, teethRadius, toolRadius, oneTeethAngle, outsideRadius);

//            outsidePoint = polar(0, 0, degToRad(angle + (oneTeethAngle / 3)), outsideRadius);
//            gear.path.push(outsidePoint);


//            gear.path.push(teethCenter);
            angle += oneTeethAngle;
            i++;
        }
        angle = 0;
        for (var i = 0; i <= 360;) {
//            polar(0, 0, teethCenter, 300);
            teethCenter = polar(0, 0, degToRad(i), outsideDiameter / 2);
//            gear.path.push(teethCenter);
            angle += oneTeethAngle;
            i++;
        }

        angle = 0;
//        for (var i = 0; i <= 360;) {
////            polar(0, 0, teethCenter, 300);
//            teethCenter = polar(0, 0, degToRad(angle), pitchDiametr/2);
//            gear.path.push(teethCenter);
//            teethCenter = polar(0, 0, degToRad(angle), 2);
//            gear.path.push(teethCenter);
//            angle += oneTeethAngle;
//            i++;
//        }

//        console.log(path);


        for (var i = 0; i <= 360; i++) {

            outsidePoint = polar(0, 0, degToRad(i), 3 / 2);
            gear.path.push(outsidePoint);
        }

        addPath(gear);
//        gear.line.geometry.translate(-(width / 2), -(depth / 2), (height / 2));

        gears.push(gear);
        scene.add(gear.line);

    }

    function init() {


//        original 20.9;
        camera = new THREE.PerspectiveCamera(1, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 400;

        scene = new THREE.Scene();
        var texture = new THREE.TextureLoader().load('textures/fanera.jpg');

        var geometry = new THREE.RingBufferGeometry(100, 120, 1000);
        var material = new THREE.MeshBasicMaterial({map: texture});
        mesh = new THREE.Mesh(geometry, material);
//        scene.add(mesh);


        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
//        renderer.setSize(300, 300);
        renderer.domElement.id = "display";
        document.body.appendChild(renderer.domElement);
        makeGear(numberOfTeeth, teethDiametr, 0);

        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    init();
    animate();


    //    mesh.rotation.x = 0.9449999999999513;
    //    mesh.rotation.y = 1.8899999999999026;


    //    mesh.rotation.x = 0.9449999999999513;
    //    mesh.rotation.y = 1.8899999999999026;


    //    mesh.rotation.x = 2.824999999999962;
    //    mesh.rotation.y = 0.5650000000000004;

    mesh.rotation.x = degToRad(90);
    mesh.rotation.y = 0;


    gears.forEach(function (gear) {
        gear.line.rotation.x = mesh.rotation.x;
        gear.line.rotation.y = mesh.rotation.y;
    });


    var rotation_x = 0;
    var rotation_y = 0;


    function animate() {

        requestAnimationFrame(animate);
//        rotation_x += 0.005;
//        rotation_y += 0.0001;
        rotation_x = degToRad(90);


        mesh.rotation.x = rotation_x;
        mesh.rotation.y = rotation_y;
        // console.log(mesh.rotation.x,mesh.rotation.y );

        gears.forEach(function (gear) {
            gear.line.rotation.x = rotation_x;
            gear.line.rotation.y = rotation_y;
        });


        renderer.render(scene, camera);

    }
</script>
<!--<script-->
<!--src="https://code.jquery.com/jquery-3.1.1.min.js"-->
<!--integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="-->
<!--crossorigin="anonymous"></script>-->
</body>
</html>