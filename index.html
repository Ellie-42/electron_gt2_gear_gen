<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gcode box</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 10px;
            background-color: #000000;
            overflow: hidden;
        }

        #display {
            width: 300px;
            height: 300px;
        }

        .settings {
            position: absolute;
            color: white;
        }

        .settings #params label {
            text-align: right;
        }

        .settings label {
            display: inline-block;
            width: 150px;
        }

        .settings input {
            width: 50px;
        }

        #g-code {
            width: 200px;
            height: 100px;
        }

    </style>
</head>
<body>
<div class="settings">
    <legend id="params">
        <label for="params">Settings</label>

        <div>
            <label>Number Of Teeth</label>
            <input type="number" placeholder="width" min="3" onchange="changeParam('numberOfTeeth',this);" value="30"/>
        </div>
        <div>
            <label>Central hole</label>
            <input type="number" placeholder="height" onchange="changeParam('centralHole',this);" value="3"/>
        </div>
        <div>
            <label>Number of radial holes</label>
            <input type="number" placeholder="height" onchange="changeParam('numberOfRadialRoles',this);" value="4"/>
        </div>
        <div>
            <label>Radial holes diameter</label>
            <input type="number" placeholder="height" onchange="changeParam('radialHolesdiameter',this);" value="3"/>
        </div>
        <div>
            <label>Radial holes distance</label>
            <input type="number" placeholder="height" onchange="changeParam('radialHolesDistance',this);" value="3"/>
        </div>
        <div>
            <label>Work Speed</label>
            <input onchange="changeParam('workSpeed',this);" type="number" placeholder="Work Speed" value="150"/>
        </div>
        <div>
            <label>Speed</label>
            <input onchange="changeParam('speed',this);" type="number" placeholder="Speed" value="400"/>
        </div>
        <div>
            <label>Offset</label>
            <input onchange="changeParam('offset',this);" type="number" placeholder="Speed" value="400"/>
        </div>
        <div>
            <label>Laser Power</label>
            <input onchange="changeParam('laserPower',this);" type="number" placeholder="clamp" value="200"/>
        </div>
    </legend>
    <legend id="export">
        <label for="export">Export</label>

        <div>
            <!--<button>DXF</button>-->
            <!--<button>SVG</button>-->
            <button onclick="dataExport('g-code');">G code</button>
        </div>
        <textarea id="g-code"></textarea>
    </legend>
</div>
<script src="three.js"></script>

<script>


    var gcodeExporter = {
        'circle': function (shape) {
            var str = "";
            var ofx = shape.center.x - shape.radius;
            str += "(circle x=" + shape.center.x + " y=" + shape.center.y + " radius=" + shape.radius + ")\n";
            str += "G0 X" + ofx.toFixed(3) + " Y" + shape.center.y.toFixed(3) + " (rapid to start)\n";
            str += "G17 G2 X" + ofx.toFixed(3) + " Y" + shape.center.y.toFixed(3) + " I" + shape.radius.toFixed(3) + " J0.000\n";

            str += "(end of circle)\n\n";
            return str;
        },
        'arc': function (shape) {
            var Theta1 = vectorAngle(shape.center, shape.from);
            var I = (shape.center.x - (Math.abs(shape.radius) * Math.cos(Theta1 * Math.PI / 180))) - shape.center.x;
            var J = (shape.center.y - (Math.abs(shape.radius) * Math.sin(Theta1 * Math.PI / 180))) - shape.center.y;

            return "G0 X" + shape.from.x.toFixed(3) + " Y" + shape.from.y.toFixed(3) + "\n" +
                    (shape.radius > 0 ? "G3" : "G2") + " X" + shape.to.x.toFixed(3) + " Y" + shape.to.y.toFixed(3) + "  I" + I.toFixed(3) + " J" + J.toFixed(3) + "\n";

        },
        'line': function (shape) {
            return "";
        }
    };


    var gt2Constants = {
        '2': {
            'grooveDepth': 0.76,
            'pitchFactor': 0.41,
            'pld': 0.254,
            'insideDiameter': 0.555,
            'insideRoundDiameter': 1,
            'outsideRoundDiameter': 0.15
        },
        '3': {
            'grooveDepth': 1.14,
            'pitchFactor': 1.27,
            'insideDiameter': 0.555,
            'insideRoundDiameter': 1,
            'outsideRoundDiameter': 0.15
        },
        '5': {
            'grooveDepth': 1.93,
            'pitchFactor': 1.78,
            'insideDiameter': 0.555,
            'insideRoundDiameter': 1,
            'outsideRoundDiameter': 0.15
        }
    };


    var settings = {
        "numberOfTeeth": 30,
        "centralHole": 3,
        "numberOfRadialRoles": 4,
        "radialHolesdiameter": 3,
        "radialHolesDistance": 5,
        "workSpeed": 100,
        "speed": 100,
        "offset": 0,
        "laserPower": 200,
        "gerType": gt2Constants['2']

    };
    var gearCenter = {x: 0, y: 0, z: 0};

    var shapes = [];
    var camera, scene, renderer;

    function degToRad(angle) {
        return (angle * Math.PI) / 180;
    }

    function distance(p1, p2) {
        var dx = p1.x - p2.x;
        var dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function vectorAngle(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI
    }

    function pointToFixed(p) {

        var x = p.x;
        var y = p.y;

        return {'x': x.toFixed(3), 'y': y.toFixed(3)};

    }


    function dataExport(type) {
        textarea.value = "";
        var offsetX = 0;
        var offsetY = 0;
        var exporter = {};

        if (type == 'g-code') {
            exporter = gcodeExporter;

            textarea.value += "G90\n";
            textarea.value += "S" + settings.laserPower + "\n";
            textarea.value += "F" + settings.workSpeed + "\n";
            textarea.value += "G0 X0.000 Y0.000\n";

            var p1, p2;
            shapes.forEach(function (shape, index) {

//                textarea.value += "M5\n";

                textarea.value += exporter[shape.type](shape);

//                textarea.value += "F" + settings.speed + "\n";

            });
            textarea.value += "G0 X0.000 Y0.000\n";
            textarea.value += "M2\n";
        }
    }
    var textarea = document.getElementById('g-code');

    function exportShapeGcode(shape) {


        textarea.value += shape.type + "\n";


    }


    function conver_rtg(e) {
        return 180 / Math.PI * e
    }
    function conver_gtr(e) {
        return e / (180 / Math.PI)
    }


    function trangleAnglesBySides(a, b, c) {

        var angle_1 = 0;
        var angle_3 = 0;
        var angle_2 = 0;

        if (a + b <= c || a + c <= b || b + c <= a) {
            console.log('sides error');
        } else {
            angle_1 = conver_rtg(Math.acos((a * a + c * c - b * b) / (2 * a * c)));
            angle_3 = conver_rtg(Math.acos((b * b + c * c - a * a) / (2 * b * c)));
            angle_2 = 180 - angle_1 - angle_3
        }

        return {
            'cb': angle_1,
            'ac': angle_3,
            'ba': angle_2
        }

    }

    function getInsideRoundPoint(angle, rootRadius, outsideRadius, center, type) {

        var offset = 0.4;
        var centerRadius = 0.55;
        var hordDistance = outsideRadius - (rootRadius + centerRadius);
        var distance = Math.sqrt(hordDistance * hordDistance + offset * offset);
        var angles = trangleAnglesBySides(hordDistance, distance, offset);
        var angleMargin = angles.ba;
        var point;
        var a = 0;
        if (type == 'l') {
            a = angle + angleMargin;
        } else if (type == 'r') {
            a = angle - angleMargin;
        }
        point = polar(center, a, distance);
        point.sharedPoint = polar(center, a - 180, centerRadius);
        return point;
    }


    function anglesBySideAndAngle(a, b, y) {

        var angle_2 = y;
        var side_1 = b;
        var side_2 = a;
        if (180 <= angle_2) {
            oForm.error_msg(3)
        } else {
            side_3 = Math.sqrt(side_2 * side_2 + side_1 * side_1 - 2 * side_2 * side_1 * Math.cos(conver_gtr(angle_2)));
            angle_1 = conver_rtg(Math.acos((side_1 * side_1 + side_3 * side_3 - side_2 * side_2) / (2 * side_1 * side_3)));
            angle_3 = 180 - angle_2 - angle_1
        }

        return trangleAnglesBySides(b, a, side_3);

    }


    function getOutsideRoundPoint(center, outsideRadius, insideRadius, angle, type) {

        var angles = anglesBySideAndAngle(insideRadius + outsideRadius, outsideRadius, 90);
        var angleMargin = angles.cb;

//        console.log(angles);
        var point;
        var a = 0;
        if (type == 'l') {
            a = angle + angleMargin;
        } else if (type == 'r') {
            a = angle - angleMargin;
        }
        point = polar(center, a - 180, insideRadius + outsideRadius);
//        addLine(center, point);
        point.sharedPoint = polar(center, a - 180, insideRadius);
        point.edgeSharedPoint = polar(point, angle, outsideRadius);

        return point;
    }

    function changeParam(type, el) {

        if (type == "numberOfTeeth") {
            settings.numberOfTeeth = parseFloat(el.value);
        } else if (type == "centralHole") {
            settings.centralHole = parseFloat(el.value);
        } else if (type == "numberOfRadialRoles") {
            settings.numberOfRadialRoles = parseFloat(el.value);
        } else if (type == "radialHolesdiameter") {
            settings.radialHolesdiameter = parseFloat(el.value);
        } else if (type == "radialHolesDistance") {
            settings.radialHolesDistance = parseFloat(el.value);
        } else if (type == "workSpeed") {
            settings.workSpeed = parseFloat(el.value);
        } else if (type == "speed") {
            settings.speed = parseFloat(el.value);
        } else if (type == "offset") {
            settings.offset = parseFloat(el.value);
        } else if (type == "laserPower") {
            settings.laserPower = parseFloat(el.value);
        }

        shapes.forEach(function (shape) {
            scene.remove(shape.line);
        });

        makeGear(settings);
    }

    function polar(point, direct, dist) {
        direct = degToRad(direct);
        return {
            'x': ((dist * Math.cos(direct)) + point.x),
            'y': ((dist * Math.sin(direct)) + point.y),
            'z': 0
        }
    }

    function radToDeg(angle) {
        return (angle * 180) / Math.PI;
    }


    function addPath(teeth) {
        teeth.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(teeth.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = teeth.path.length; i < l; i++) {
            var positions = teeth.geometry.attributes.position.array;
            positions[index++] = teeth.path[i].y;
            positions[index++] = teeth.path[i].z;
            positions[index++] = teeth.path[i].x;
        }
    }


    function addLine(from, to, color) {

        if (color == null) {
            color = 0xFFFFFF;
        }

        var circle = {
            'type': 'line',
            'from': from,
            'to': to,
            'geometry': new THREE.BufferGeometry(),
            'material': new THREE.LineBasicMaterial({
                color: color
                // color: Math.random() * 0xFFFFFF << 0
            }),
            'path': [from, to],
            'line': null
        };

        circle.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(circle.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = circle.path.length; i < l; i++) {
            var positions = circle.geometry.attributes.position.array;
            positions[index++] = circle.path[i].y;
            positions[index++] = circle.path[i].z;
            positions[index++] = circle.path[i].x;
        }

        circle.line = new THREE.Line(circle.geometry, circle.material)
        circle.line.rotation.x = degToRad(90);


        scene.add(circle.line);
        shapes.push(circle);
    }

    function addCircle(radius, point) {

        var geometry = new THREE.BufferGeometry();
        var material = new THREE.LineBasicMaterial();

        var circle = {
            'type': 'circle',
            'center': point,
            'radius': radius,
            'geometry': geometry,
            'material': material,
            'path': [],
            'line': null
        };

        var angle = 0;
        while (angle <= 360) {
            if (point) {
                circle.path.push(polar(point, angle, radius));
            } else {
                circle.path.push(polar({'x': 0, 'y': 0}, angle, radius));
            }
            angle++;
        }
        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(circle.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = circle.path.length; i < l; i++) {
            var positions = geometry.attributes.position.array;
            positions[index++] = circle.path[i].y;
            positions[index++] = circle.path[i].z;
            positions[index++] = circle.path[i].x;
        }

        circle.line = new THREE.Line(geometry, material)
        circle.line.rotation.x = degToRad(90);


        scene.add(circle.line);
        shapes.push(circle);
    }

    function drawArc(path, center, radius, angle, startAngle, direction) {


        var geometry = new THREE.BufferGeometry();
        var material = new THREE.LineBasicMaterial({
//            color: 0xFF0000
            color: Math.random() * 0xFFFFFF << 0
        });

        var circle = {
            'geometry': geometry,
            'material': material,
            'path': [],
            'line': null
        };

        var limit = 0;
        if (direction == 'cw') {
            limit = startAngle - angle;
            while (startAngle >= limit) {
                circle.path.push(polar(center, startAngle, radius));
                startAngle -= 0.1;
            }
            circle.path.push(polar(center, startAngle, radius));
            console.log('final angle', limit);


        } else {
            limit = startAngle + angle;
            while (startAngle <= limit) {
                circle.path.push(polar(center, startAngle, radius));
                startAngle += 0.1;
            }
            circle.path.push(polar(center, startAngle, radius));
            console.log('final angle', startAngle);

        }

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(circle.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = circle.path.length; i < l; i++) {
            var positions = geometry.attributes.position.array;
            positions[index++] = circle.path[i].y;
            positions[index++] = circle.path[i].z;
            positions[index++] = circle.path[i].x;
        }


//        addLine(circle.path[0], center);
//        addLine(circle.path[circle.path.length - 1], center);

        circle.line = new THREE.Line(geometry, material);
        circle.line.rotation.x = degToRad(90);


        scene.add(circle.line);
        shapes.push(circle);

        return circle.path[circle.path.length - 1];

    }

    function addArc(from, to, radius) {

//        console.log('next shape');
        var type = radius > 0 ? 'l' : 'r';
        var i = 1;

        var arc = {
            'type': 'arc',
            'from': from,
            'to': to,
            'radius': radius,
            'gcode': '',
            'center': null,
            'geometry': new THREE.BufferGeometry(),
            'material': new THREE.LineBasicMaterial({
                color: 0xFF0000
//                color: Math.random() * 0xFFFFFF << 0
            }),
            'path': [],
            'line': null
        };

        radius = Math.abs(radius);


//        addLine(from, to);

        var distanse = distance(from, to);
        var angles = trangleAnglesBySides(radius, radius, distanse);

        if (angles.ac == 0) {
            console.warn('minimum shape radius:' + (distanse / 2) + ' given:' + radius);
            return
        }

        var insideAngle = angles.ba;
        var shiftAngle = angles.ac;

        var initAngle = vectorAngle(from, to);

        var direction = 0;
        if (type == "l") {
            direction = initAngle + shiftAngle;
        }
        else {
            direction = initAngle - shiftAngle;
        }

        arc.center = polar(from, direction, radius);
        if (type == "l") {
            var addodn = vectorAngle(arc.center, from);
            while (insideAngle >= 0) {
                arc.path.push(polar(arc.center, insideAngle + addodn, radius));
                insideAngle -= 0.1;
            }
        } else {
            var addodn = vectorAngle(arc.center, to);
            i = 0;
            while (i <= insideAngle) {
                arc.path.push(polar(arc.center, i + addodn, radius));
                i += 1;
            }
        }
//
//        addLine(arc.center, to, 0x00FF00);
//        addLine(from, arc.center, 0x0000FF);


        arc.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(arc.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = arc.path.length; i < l; i++) {
            var positions = arc.geometry.attributes.position.array;
            positions[index++] = arc.path[i].y;
            positions[index++] = arc.path[i].z;
            positions[index++] = arc.path[i].x;
        }


        arc.line = new THREE.Line(arc.geometry, arc.material);
//        arc.line.rotation.x = degToRad(90);


        scene.add(arc.line);
        shapes.push(arc);


        return {
            'from': from,
            'to': to,
            'radius': radius,
            'gcode': '',
            'center': arc.center
        };

        console.log(distanse, angles);
    }


    function generateTeeth(config, angle, nextteeth) {

        var roundRadius = config.baseConfig.gerType.insideDiameter;
        var insideRoundRadius = config.baseConfig.gerType.insideRoundDiameter;
        var outsideRoundRadius = config.baseConfig.gerType.outsideRoundDiameter;

        var startPoint = polar(gearCenter, angle, config.rootRadius);
        var teethCenter = polar(gearCenter, angle, (config.rootRadius + roundRadius));

        var leftInsideRoundPoint = getInsideRoundPoint(angle, config.rootRadius, config.outsideRadius, teethCenter, 'l');
        var rightInsideRoundPoint = getInsideRoundPoint(angle, config.rootRadius, config.outsideRadius, teethCenter, 'r');
        var leftOutsideRoundPoint = getOutsideRoundPoint(leftInsideRoundPoint, outsideRoundRadius, insideRoundRadius, angle, 'l');
        var rightOutsideRoundPoint = getOutsideRoundPoint(rightInsideRoundPoint, outsideRoundRadius, insideRoundRadius, angle, 'r');

        if (nextteeth) {
            addArc(leftOutsideRoundPoint.edgeSharedPoint, leftOutsideRoundPoint.sharedPoint, outsideRoundRadius);

            addArc(leftOutsideRoundPoint.sharedPoint, leftInsideRoundPoint.sharedPoint, insideRoundRadius * -1);
            addArc(leftInsideRoundPoint.sharedPoint, startPoint, roundRadius * -1);
            addArc(startPoint, rightInsideRoundPoint.sharedPoint, roundRadius * -1);
            addArc(rightInsideRoundPoint.sharedPoint, rightOutsideRoundPoint.sharedPoint, insideRoundRadius * -1);
//            addArc(rightOutsideRoundPoint.sharedPoint, rightOutsideRoundPoint.edgeSharedPoint, outsideRoundRadius);

            addArc(rightOutsideRoundPoint.sharedPoint, rightOutsideRoundPoint.edgeSharedPoint, outsideRoundRadius);

            addArc(rightOutsideRoundPoint.edgeSharedPoint, nextteeth.start, config.outsideRadius * -1);

//        addCircle(insideRoundRadius, leftInsideRoundPoint);
//        addCircle(insideRoundRadius, rightInsideRoundPoint);
//        addCircle(outsideRoundRadius, leftOutsideRoundPoint);
//        addCircle(outsideRoundRadius, rightOutsideRoundPoint);
//        addCircle(roundRadius, teethCenter);


        }


        return {
            'start': leftOutsideRoundPoint.edgeSharedPoint,
            'end': rightOutsideRoundPoint.edgeSharedPoint

        }

    }

    function makeGear(settings) {

        var oneTeethAngle = (360 / settings.numberOfTeeth);

        var pitchRadius = (((2 * settings.numberOfTeeth) / Math.PI) / 2);
        var pitchDiametr = pitchRadius * 2;
        var outsideDiameter = pitchDiametr - (settings.gerType.pld * 2);
        var outsideRadius = outsideDiameter / 2;
        var rootDiameter = outsideDiameter - ( settings.gerType.grooveDepth * 2);
        var rootRadius = rootDiameter / 2;


        gearCenter.x = pitchRadius;
        gearCenter.y = pitchRadius;

        camera.position.x = pitchRadius;
        camera.position.y = -pitchRadius;


        var teethConfig = {
            "oneTeethAngle": oneTeethAngle,
            "pitchRadius": pitchRadius,
            "pitchDiametr": pitchDiametr,
            "outsideDiameter": outsideDiameter,
            "outsideRadius": outsideRadius,
            "rootDiameter": rootDiameter,
            "rootRadius": rootRadius,
            "baseConfig": settings
        };

//        addCircle(rootRadius);
//        addCircle(outsideRadius - 0.15);
//        addCircle(pitchRadius);
        addCircle(settings.centralHole / 2, gearCenter);

//        console.log(pitchDiametr, outsideDiameter, rootDiameter);

        var edgePoints = [];
        var teethAngle = 0;

        var nextTeetch
        for (var i = 0; i < settings.numberOfTeeth;) {
            nextTeetch = null;
            if (teethAngle + oneTeethAngle < 360) {
            }
            nextTeetch = generateTeeth(teethConfig, teethAngle + oneTeethAngle);

            edgePoints.push(generateTeeth(teethConfig, teethAngle, nextTeetch));
            teethAngle += oneTeethAngle;
            i++;
        }


        var holeAngle = 0;
        var radialHoleCenter;
        var oneholeAngle = 360 / settings.numberOfRadialRoles;
        if (settings.numberOfRadialRoles >= 2) {
            for (var i = 0; i <= settings.numberOfRadialRoles; i++) {
                radialHoleCenter = polar(gearCenter, holeAngle, settings.radialHolesDistance);
                addCircle(settings.radialHolesdiameter / 2, radialHoleCenter);
                holeAngle += oneholeAngle;
            }
        }


        var nextPoint = null;
        var currentPoint = null;
        for (var i = 0; i < edgePoints.length; i++) {
            nextPoint = i + 1;
            currentPoint = i;
            if (nextPoint != edgePoints.length) {
//                addArc(edgePoints[currentPoint].end, edgePoints[nextPoint].start, outsideRadius);
            }
        }
        //        addCircle(outsideRadius);
    }

    function init() {


//        original 20.9;
        camera = new THREE.PerspectiveCamera(5, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 400;

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = "display";
        document.body.appendChild(renderer.domElement);
        makeGear(settings);


//        addArc({x: 2.25, y: 3.5,'z':0}, {x: 2.75, y: 3,'z':0}, -0.5);
//        addArc({x: 0.5, y: -2,'z':0}, {x: -0.5, y: -2,'z':0}, -0.5);
//        addArc({x:3,y:0},{x:-3,y:0},3);
//        addArc({x:-3,y:0},{x:-3,y:3},-3);

        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    init();
    animate();
    var rotation_x = degToRad(90);
    var rotation_y = 0;

    function animate() {

        requestAnimationFrame(animate);
        shapes.forEach(function (gear) {
            gear.line.rotation.x = rotation_x;
            gear.line.rotation.y = rotation_y;
        });
        renderer.render(scene, camera);

    }
</script>
<!--<script-->
<!--src="https://code.jquery.com/jquery-3.1.1.min.js"-->
<!--integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="-->
<!--crossorigin="anonymous"></script>-->
<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
        a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-90392164-1', 'auto');
    ga('send', 'pageview');

    var a = Math.cos(90 * Math.PI / 180).toFixed(15);

    console.log(a);

</script>
</body>
</html>