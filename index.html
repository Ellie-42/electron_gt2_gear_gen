<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gcode box</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 10px;
            background-color: #000000;
            overflow: hidden;
        }

        #display {
            width: 300px;
            height: 300px;
        }

        .settings {
            position: absolute;
            color: white;
        }

        .settings #params label {
            text-align: right;
        }

        .settings label {
            display: inline-block;
            width: 150px;
        }

        .settings input {
            width: 50px;
        }

        #g-code {
            width: 200px;
            height: 100px;
        }

    </style>
</head>
<body>
<div class="settings">
    <legend id="params">
        <label for="params">Settings</label>

        <div>
            <label>Number Of Teeth</label>
            <input type="number" placeholder="width" min="3" onchange="changeParam('numberOfTeeth',this);" value="12"/>
        </div>
        <div>
            <label>Teeth diametr, mm</label>
            <input type="number" placeholder="height" onchange="changeParam('teethDiametr',this);" value="0.55"/>
        </div>
        <div>
            <label>Work Speed</label>
            <input onchange="changeSize('workSpeed',this);" type="number" placeholder="Work Speed" value="150"/>
        </div>
        <div>
            <label>Speed</label>
            <input onchange="changeSize('speed',this);" type="number" placeholder="Speed" value="400"/>
        </div>
        <div>
            <label>Laser Power</label>
            <input onchange="changeSize('laserPower',this);" type="number" placeholder="clamp" value="200"/>
        </div>
    </legend>
    <!--<legend id="export">-->
    <!--<label for="export">Export</label>-->

    <!--<div>-->
    <!--&lt;!&ndash;<button>DXF</button>&ndash;&gt;-->
    <!--&lt;!&ndash;<button>SVG</button>&ndash;&gt;-->
    <!--<button onclick="dataExport('g-code');">G code</button>-->
    <!--</div>-->
    <!--<textarea id="g-code"></textarea>-->
    <!--</legend>-->
</div>
<script src="three.js"></script>

<script>

    var gearCenter = {x: 0, y: 0, z: 0};

    var gt2Constants = {
        '2': {
            'grooveDepth': 0.76,
            'pitchFactor': 0.41,
            'pld': 0.254
        },
        '3': {
            'grooveDepth': 1.14,
            'pitchFactor': 1.27
        },
        '5': {
            'grooveDepth': 1.93,
            'pitchFactor': 1.78
        }
    };

    var numberOfTeeth = 20;
    var teethDiametr = 0.55;
    var gears = [];
    var camera, scene, renderer;
    var mesh;

    function degToRad(angle) {
        return (angle * Math.PI) / 180;
    }

    function distance(p1, p2) {
        var dx = p1.x - p2.x;
        var dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function vectorAngle(p1, p2, zero) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI
    }


    function conver_rtg(e) {
        return 180 / Math.PI * e
    }
    function conver_gtr(e) {
        return e / (180 / Math.PI)
    }


    function trangleAnglesBySides(a, b, c) {

        var angle_1 = 0;
        var angle_3 = 0;
        var angle_2 = 0;

        if (a + b <= c || a + c <= b || b + c <= a) {
            console.log('sides error');
        } else {
            angle_1 = conver_rtg(Math.acos((a * a + c * c - b * b) / (2 * a * c)));
            angle_3 = conver_rtg(Math.acos((b * b + c * c - a * a) / (2 * b * c)));
            angle_2 = 180 - angle_1 - angle_3
        }

        return {
            'cb': angle_1,
            'ac': angle_3,
            'ba': angle_2
        }

    }

    function getInsideRoundPoint(angle, rootRadius, outsideRadius, center, type) {

        var offset = 0.4;
        var centerRadius = 0.55;
        var hordDistance = outsideRadius - (rootRadius + centerRadius);
        var distance = Math.sqrt(hordDistance * hordDistance + offset * offset);
        var angles = trangleAnglesBySides(hordDistance, distance, offset);
        var angleMargin = angles.ba;
        var point;
        var a = 0;
        if (type == 'l') {
            a = angle + angleMargin;
        } else if (type == 'r') {
            a = angle - angleMargin;
        }
        point = polar(center, a, distance);
        point.sharedPoint = polar(center, a - 180, centerRadius);
        return point;
    }


    function anglesBySideAndAngle(a, b, y) {

        var angle_2 = y;
        var side_1 = b;
        var side_2 = a;
        if (180 <= angle_2) {
            oForm.error_msg(3)
        } else {
            side_3 = Math.sqrt(side_2 * side_2 + side_1 * side_1 - 2 * side_2 * side_1 * Math.cos(conver_gtr(angle_2)));
            angle_1 = conver_rtg(Math.acos((side_1 * side_1 + side_3 * side_3 - side_2 * side_2) / (2 * side_1 * side_3)));
            angle_3 = 180 - angle_2 - angle_1
        }

        return trangleAnglesBySides(b, a, side_3);

    }


    function getOutsideRoundPoint(center, outsideRadius, insideRadius, angle, type) {

        var angles = anglesBySideAndAngle(insideRadius + outsideRadius, outsideRadius, 90);
        var angleMargin = angles.cb;

        console.log(angles);
        var point;
        var a = 0;
        if (type == 'l') {
            a = angle + angleMargin;
        } else if (type == 'r') {
            a = angle - angleMargin;
        }
        point = polar(center, a - 180, insideRadius + outsideRadius);
//        addLine(center, point);
        point.sharedPoint = polar(center, a - 180, insideRadius);
        point.edgeSharedPoint = polar(point, angle, outsideRadius);

        return point;
    }

    function changeParam(type, el) {

        if (type == 'numberOfTeeth') {
            numberOfTeeth = parseInt(el.value);
        } else if (type == 'teethDiametr') {
            teethDiametr = parseFloat(el.value);

        }

        gears.forEach(function (gear) {
            scene.remove(gear.line);
        });

        makeGear(numberOfTeeth, teethDiametr, 0);
    }

    function polar(point, direct, dist) {
        direct = degToRad(direct);
        return {
            'x': ((dist * Math.cos(direct)) + point.x),
            'y': ((dist * Math.sin(direct)) + point.y),
            'z': 0
        }
    }

    function radToDeg(angle) {
        return (angle * 180) / Math.PI;
    }


    function addPath(teeth) {
        teeth.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(teeth.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = teeth.path.length; i < l; i++) {
            var positions = teeth.geometry.attributes.position.array;
            positions[index++] = teeth.path[i].y;
            positions[index++] = teeth.path[i].z;
            positions[index++] = teeth.path[i].x;
        }
    }


    function addLine(from, to, color) {

        if (color == null) {
            color = 0xFFFFFF;
        }
        var material = new THREE.LineBasicMaterial({
            color: color
            // color: Math.random() * 0xFFFFFF << 0
        });

        var circle = {
            'geometry': geometry,
            'material': material,
            'path': [from, to],
            'line': null
        };

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(circle.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = circle.path.length; i < l; i++) {
            var positions = geometry.attributes.position.array;
            positions[index++] = circle.path[i].y;
            positions[index++] = circle.path[i].z;
            positions[index++] = circle.path[i].x;
        }

        circle.line = new THREE.Line(geometry, material)
        circle.line.rotation.x = degToRad(90);


        scene.add(circle.line);
        gears.push(circle);
    }

    function addCircle(radius, point) {

        var geometry = new THREE.BufferGeometry();
        var material = new THREE.LineBasicMaterial();

        var circle = {
            'geometry': geometry,
            'material': material,
            'path': [],
            'line': null
        };

        var angle = 0;
        while (angle <= 360) {
            if (point) {
                circle.path.push(polar(point, angle, radius));
            } else {
                circle.path.push(polar({'x': 0, 'y': 0}, angle, radius));
            }
            angle++;
        }
        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(circle.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = circle.path.length; i < l; i++) {
            var positions = geometry.attributes.position.array;
            positions[index++] = circle.path[i].y;
            positions[index++] = circle.path[i].z;
            positions[index++] = circle.path[i].x;
        }

        circle.line = new THREE.Line(geometry, material)
        circle.line.rotation.x = degToRad(90);


        scene.add(circle.line);
        gears.push(circle);
    }

    function find_angle(p0, p1, c, debug) {

//        console.log(p0, p1, c);


        var p0c = Math.sqrt(Math.pow(c.x - p0.x, 2) +
                Math.pow(c.y - p0.y, 2)); // p0->c (b)
        var p1c = Math.sqrt(Math.pow(c.x - p1.x, 2) +
                Math.pow(c.y - p1.y, 2)); // p1->c (a)
        var p0p1 = Math.sqrt(Math.pow(p1.x - p0.x, 2) +
                Math.pow(p1.y - p0.y, 2)); // p0->p1 (c)

        var aa = radToDeg(Math.acos((p1c * p1c + p0c * p0c - p0p1 * p0p1) / (2 * p1c * p0c)));

        if (debug) {
            addLine(c, p1);
            addLine(c, p0);

            console.log('measured angle', aa);
        }
        return aa;
    }

    function extracted(teethCenter, angle, angleDiff, teethRadius, roundRadius) {
        var rightEdgePoint = polar(teethCenter, (angle + 90 + angleDiff), teethRadius);
        var rightCenterPoint = polar(rightEdgePoint, (angle + 90 + angleDiff), roundRadius);
        return rightCenterPoint;
    }


    function drawArc(path, center, radius, angle, startAngle, direction) {


        var geometry = new THREE.BufferGeometry();
        var material = new THREE.LineBasicMaterial({
//            color: 0xFF0000
            color: Math.random() * 0xFFFFFF << 0
        });

        var circle = {
            'geometry': geometry,
            'material': material,
            'path': [],
            'line': null
        };

        var limit = 0;
        if (direction == 'cw') {
            limit = startAngle - angle;
            while (startAngle >= limit) {
                circle.path.push(polar(center, startAngle, radius));
                startAngle -= 0.1;
            }
            circle.path.push(polar(center, startAngle, radius));
            console.log('final angle', limit);


        } else {
            limit = startAngle + angle;
            while (startAngle <= limit) {
                circle.path.push(polar(center, startAngle, radius));
                startAngle += 0.1;
            }
            circle.path.push(polar(center, startAngle, radius));
            console.log('final angle', startAngle);


        }

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(circle.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = circle.path.length; i < l; i++) {
            var positions = geometry.attributes.position.array;
            positions[index++] = circle.path[i].y;
            positions[index++] = circle.path[i].z;
            positions[index++] = circle.path[i].x;
        }


//        addLine(circle.path[0], center);
//        addLine(circle.path[circle.path.length - 1], center);

        circle.line = new THREE.Line(geometry, material);
        circle.line.rotation.x = degToRad(90);


        scene.add(circle.line);
        gears.push(circle);

        return circle.path[circle.path.length - 1];

    }

    function drawArc2(path, center, radius, startAngle, endAngle) {


        var arc = {
            'geometry': new THREE.BufferGeometry(),
            'material': new THREE.LineBasicMaterial({
//            color: 0xFF0000
                color: Math.random() * 0xFFFFFF << 0
            }),
            'path': [],
            'line': null
        };

        arc.path.push(polar(center, startAngle, radius));
        arc.path.push(polar(center, startAngle, radius));


        arc.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(circle.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = circle.path.length; i < l; i++) {
            var positions = arc.geometry.attributes.position.array;
            positions[index++] = arc.path[i].y;
            positions[index++] = arc.path[i].z;
            positions[index++] = arc.path[i].x;
        }


        arc.line = new THREE.Line(arc.geometry, arc.material);
        arc.line.rotation.x = degToRad(90);


        scene.add(arc.line);
        gears.push(arc);

        return arc.path[arc.path.length - 1];

    }


    function getCirclesSharedPoint(insidePoint, insideRadius, outsidePoint, outsideRadius) {
        var distanse = distance(insidePoint, outsidePoint);
        var difference = (outsideRadius - insideRadius);
        console.log(distanse.toPrecision(2), difference.toPrecision(2));
        if (distanse == (outsideRadius - insideRadius)) {


        }


    }

    function addAutoArc(from, to, radius) {

        console.log('next shape');
        var type = radius > 0 ? 'l' : 'r';
        var i = 1;
        radius = Math.abs(radius);

        var arc = {
            'geometry': new THREE.BufferGeometry(),
            'material': new THREE.LineBasicMaterial({
//            color: 0xFF0000
                color: Math.random() * 0xFFFFFF << 0
            }),
            'path': [],
            'line': null
        };

//        addLine(from, to);

        var distanse = distance(from, to);
        var angles = trangleAnglesBySides(radius, radius, distanse);

        if (angles.ac == 0) {
            console.warn('minimum shape radius:' + (distanse / 2) + ' given:' + radius);
            return
        }

//        console.log(angles, radius, radius, distanse);

        var insideAngle = angles.ba;
        var shiftAngle = angles.ac;

        var initAngle = vectorAngle(from, to);

        var direction = 0;
        if (type == "l") {
            direction = initAngle + shiftAngle;
        }
        else {
            direction = initAngle - shiftAngle;
        }


        console.log('direction', direction);
        var center = polar(from, direction, radius);

        var test = polar(center, 130, 4);

//        addLine(center, test, 0xFF0000);


        var initAngleA = vectorAngle(center, from, 0);


        console.log('initAngleA', initAngleA);
        console.log('insideAngle', insideAngle);
        if (type == "l") {

            initAngleA = initAngle;
            var addodn = vectorAngle(center, from);

            while (insideAngle >= 0) {
                arc.path.push(polar(center, insideAngle + addodn, radius));
                insideAngle -= 0.1;
            }
        } else {
            var addodn = vectorAngle(center, to);
            i = 0;
            while (i <= insideAngle) {
                arc.path.push(polar(center, i + addodn, radius));
//                console.log(i);
                i += 1;
            }

        }

//        addLine(center, to, 0x00FF00);
//        addLine(from, center, 0x0000FF);


        arc.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(arc.path.length * 3), 3));
        var index = 0;

        for (var i = 0, l = arc.path.length; i < l; i++) {
            var positions = arc.geometry.attributes.position.array;
            positions[index++] = arc.path[i].y;
            positions[index++] = arc.path[i].z;
            positions[index++] = arc.path[i].x;
        }


        arc.line = new THREE.Line(arc.geometry, arc.material);
//        arc.line.rotation.x = degToRad(90);


        scene.add(arc.line);
        gears.push(arc);


        return {
            'gcode': '',
            'form': from,
            'to': to,
            'center': center

        };


        console.log(distanse, angles);
    }


    function generateTeeth(path, rootRadius, angle, teethRadius, toolRadius, oneTeethAngle, outsideRadius) {

        var roundRadius = 0.555;
        var insideRoundRadius = 1;
        var outsideRoundRadius = 0.25;

        var startPoint = polar(gearCenter, angle, rootRadius);
        var teethCenter = polar(gearCenter, angle, (rootRadius + 0.555));

        var leftInsideRoundPoint = getInsideRoundPoint(angle, rootRadius, outsideRadius, teethCenter, 'l');
        var rightInsideRoundPoint = getInsideRoundPoint(angle, rootRadius, outsideRadius, teethCenter, 'r');
        var leftOutsideRoundPoint = getOutsideRoundPoint(leftInsideRoundPoint, outsideRoundRadius, insideRoundRadius, angle, 'l');
        var rightOutsideRoundPoint = getOutsideRoundPoint(rightInsideRoundPoint, outsideRoundRadius, insideRoundRadius, angle, 'r');

        addAutoArc(startPoint, leftInsideRoundPoint.sharedPoint, roundRadius);
        addAutoArc(startPoint, rightInsideRoundPoint.sharedPoint, roundRadius * -1);

        addAutoArc(leftInsideRoundPoint.sharedPoint, leftOutsideRoundPoint.sharedPoint, insideRoundRadius);
        addAutoArc(rightInsideRoundPoint.sharedPoint, rightOutsideRoundPoint.sharedPoint, insideRoundRadius * -1);
        addAutoArc(leftOutsideRoundPoint.sharedPoint, leftOutsideRoundPoint.edgeSharedPoint, outsideRoundRadius * -1);
        addAutoArc(rightOutsideRoundPoint.sharedPoint, rightOutsideRoundPoint.edgeSharedPoint, outsideRoundRadius);

//        addCircle(insideRoundRadius, leftInsideRoundPoint);
//        addCircle(insideRoundRadius, rightInsideRoundPoint);
//        addCircle(outsideRoundRadius, leftOutsideRoundPoint);
//        addCircle(outsideRoundRadius, rightOutsideRoundPoint);
//        addCircle(roundRadius, teethCenter);


        return {
            'start': leftOutsideRoundPoint.edgeSharedPoint,
            'end': rightOutsideRoundPoint.edgeSharedPoint

        }

    }

    function makeGear(numberOfTeeth, teethRadius, toolRadius) {

        var oneTeethAngle = (360 / numberOfTeeth);
        var teethAngle = 0;

        var geometry = new THREE.BufferGeometry();
        var material = new THREE.LineBasicMaterial({

            color: 0xFF0000
        });

        var pitchRadius = (((2 * numberOfTeeth) / Math.PI) / 2);
        var pitchDiametr = pitchRadius * 2;
        var outsideDiameter = pitchDiametr - (0.254 * 2);
        var outsideRadius = outsideDiameter / 2;


        var rootDiameter = outsideDiameter - (gt2Constants['2'].grooveDepth * 2);
        var rootRadius = rootDiameter / 2;
//        addCircle(rootRadius);
//        addCircle(outsideRadius - 0.15);
//        addCircle(outsideRadius);
//        addCircle(pitchRadius);

//        console.log(pitchDiametr, outsideDiameter, rootDiameter);

        var gear = {
            'geometry': geometry,
            'path': [],
            'numberOfTeeth': numberOfTeeth,
            'teethRadius': teethRadius,
            'toolRadius': toolRadius,
            'line': new THREE.Line(geometry, material)
        };

        var edgePoints = [];
        for (var i = 0; i <= numberOfTeeth;) {
            edgePoints.push(generateTeeth(gear.path, rootRadius, teethAngle, teethRadius, toolRadius, oneTeethAngle, outsideRadius));
            teethAngle += oneTeethAngle;
            i++;
        }

        var nextPoint = null;
        var currentPoint = null;
        for (var i = 0; i < edgePoints.length; i++) {
            nextPoint = i + 1;
            currentPoint = i;
            if (nextPoint != edgePoints.length) {
                addAutoArc(edgePoints[currentPoint].end, edgePoints[nextPoint].start, outsideRadius);
            }
        }


        addPath(gear);
        gear.line.rotation.x = degToRad(90);
        gears.push(gear);
        scene.add(gear.line);

    }

    function init() {


//        original 20.9;
        camera = new THREE.PerspectiveCamera(1, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 400;

        scene = new THREE.Scene();
        var texture = new THREE.TextureLoader().load('textures/fanera.jpg');

        var geometry = new THREE.RingBufferGeometry(100, 120, 1000);
        var material = new THREE.MeshBasicMaterial({map: texture});
        mesh = new THREE.Mesh(geometry, material);
//        scene.add(mesh);


        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
//        renderer.setSize(300, 300);
        renderer.domElement.id = "display";
        document.body.appendChild(renderer.domElement);
        makeGear(numberOfTeeth, teethDiametr, 0);

        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    init();
    animate();


    //    mesh.rotation.x = 0.9449999999999513;
    //    mesh.rotation.y = 1.8899999999999026;


    //    mesh.rotation.x = 0.9449999999999513;
    //    mesh.rotation.y = 1.8899999999999026;


    //    mesh.rotation.x = 2.824999999999962;
    //    mesh.rotation.y = 0.5650000000000004;

    mesh.rotation.x = degToRad(90);
    mesh.rotation.y = 0;


    gears.forEach(function (gear) {
        gear.line.rotation.x = degToRad(90);
        gear.line.rotation.y = mesh.rotation.y;
    });


    var rotation_x = 0;
    var rotation_y = 0;


    function animate() {

        requestAnimationFrame(animate);
//        rotation_x += 0.005;
//        rotation_y += 0.0001;
        rotation_x = degToRad(90);


//        mesh.rotation.x = rotation_x;
//        mesh.rotation.y = rotation_y;
        // console.log(mesh.rotation.x,mesh.rotation.y );

        gears.forEach(function (gear) {
            gear.line.rotation.x = rotation_x;
            gear.line.rotation.y = rotation_y;
        });


        renderer.render(scene, camera);

    }
</script>
<!--<script-->
<!--src="https://code.jquery.com/jquery-3.1.1.min.js"-->
<!--integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="-->
<!--crossorigin="anonymous"></script>-->
</body>
</html>